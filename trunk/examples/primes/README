
###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Parallel Sieve of Eratosthenes based on C code from Stephan Brumme
    http://create.stephan-brumme.com/eratosthenes/

       primes1_p.pl (100% Perl Code)
       primes1_c.pl (using Inline C)

 :: Practical Sieve based on serial code from Xuedong Luo (Algorithm3)

    A practical sieve algorithm for finding prime numbers
    ACM Volume 32 Issue 3, March 1989, Pages 344-346
    http://dl.acm.org/citation.cfm?doid=62065.62072

       primes2_p.pl (100% Perl Code)
       primes2_c.pl (using Inline C)

 :: Usage (please run on a 64-bit OS when N is greater than 32-bit)

    perl primes.pl <N> [ <max_workers> ] [ <cnt_only> ]

    perl primes.pl 10000 8 0   ## Display prime numbers and total count
    perl primes.pl 10000 8 1   ## Count prime numbers only
    perl primes.pl 10000       ## Count primes (default 8 workers, 1 cnt_only)

    In addition, one can check a number for primality as well as specify a
    range. The dash can be omitted before -check and -between below.

    perl primes.pl -check 23
    perl primes.pl -between 900 950 [ <max_workers> ] [ <cnt_only> ]

    The script exits with a status of 0 if a prime number was found,
    otherwise 2.


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Prime numbers are polled from an imaginary list by calculating the offset
    position and computing the value stored at that location. The computation
    is only applied for prime numbers and not composites. This, in my opinion,
    is faster than populating memory initially with primes and composites
    (both requiring the value to be computed).

    Very little memory is required to count and display all prime numbers
    between 2 and N. However, it does require 11 gigabytes of storage space
    to save all prime numbers between 2 and 1 billion to a file.

       primes2_c.pl 1000000000 8 0 > primes.out

    Workers have practically no communications requirement other than sending
    results after processing each chunk and the total count at the end of the
    run. Prime numbers are displayed to STDOUT in an orderly fashion when
    found.

 :: The two *_c.pl examples require the following 2 packages under CentOS 6.3+
    to run. The 1st time will have Inline::C compile the C code -- this takes
    some time. The 2nd run and there after runs immediately with no overhead
    to compile the inlined C code.

       yum install perl-Inline perl-Parse-RecDescent


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Primes2 is faster than primes1. The difference in time increases the
    greater N is. I ran with 32 and 48 workers at the time of testing.

    The 32-way box runs with 2x Intel Xeon E5-2660 processors with memory
    running at 1600 MHz.

    N size needed to complete in 10 second (up to billions)

       perl primes1_c.pl 24000000000   32   completes in 10.3 secs
       perl primes1_c.pl 26000000000   48   completes in 10.2 secs

       perl primes2_c.pl 35000000000   32   completes in 10.3 secs
       perl primes2_c.pl 38000000000   48   completes in 10.2 secs
    
    N = 1 Trillion (that's 12 zeroes)

       perl primes1_c.pl 1000000000000 32   completes in 16.0 mins
       perl primes1_c.pl 1000000000000 48   completes in 14.9 mins

       perl primes2_c.pl 1000000000000 32   completes in  8.2 mins
       perl primes2_c.pl 1000000000000 48   completes in  7.6 mins

       There are 37607912018 prime numbers between 2 and 1000000000000.

 :: I ran without the bank-teller queuing model to see the impact. The time
    gap between the first worker and last worker completing is greater when
    dividing the work equally among workers for 48 workers on a 32-way
    system. Notice the impact to the total running time.

       perl primes2_c.pl 1000000000000 32   completes in  8.0 mins (- 12 secs)
       perl primes2_c.pl 1000000000000 48   completes in  7.8 mins (+ 12 secs)

    The following disables the bank-queuing model for sequence. One creates a
    null structure for task_id 0 like shown. Sequence of numbers are divided
    equally among workers when task_id is greater than 0. The queuing model
    is only applicable to workers assigned task_id 0 or when omitting the
    user_tasks option.

       user_tasks => [ { }, {

          sequence   => [ 2, $N, $step_size ],

          user_begin => sub { ... },
          user_func  => sub { ... },
          user_end   => sub { ... }

       } ]

 :: Equally important is the overhead of the queuing model (32 workers on a
    32-way box). The time difference is very minimal for 1.85 million steps
    for a sequence of numbers between 2 and N = 1_trillion and stepping at
    a step_size of 18 * 15000 * 2 in the code. It's mind boggling to me.

    Workers perform bank-queuing independently among themselves without any
    involvement of the main manager process. MCE is written entirely in Perl
    and is hard to believe. 154,000 sequence steps were distributed above
    per second. Pack/unpack are handled in parallel behind the scene as
    workers write_to and read_from the queuing socket.


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Thanks to Stephan Brumme for the initial inspiration. I wanted faster,
    continued looking and came across the practical sieve algorithm by
    Xuedone Luo (Algorithm3). Although serial code, thought it could run
    faster than primes1 if parallelized and indeed it does.

    Each worker utilizes only 8 ~ 10 MB no matter the size of N. Chunking
    in MCE makes this possible. Having an imaginary memory, that was the
    thought process, helped me rearrange the logic around. Why compute both
    primes and composites in the array when composites will eventually be
    crossed out. Therefore, computing composites is not necessary IMHO.

    Imaginary memory is of unlimited size. Computing the offset position
    into this memory space out weighs the cost of having a system with
    massive amount of memory for sieving prime numbers.

    
    -- Mario


