
###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Parallel Sieve of Eratosthenes based on C code from Stephan Brumme
    http://create.stephan-brumme.com/eratosthenes/

       primes1_p.pl (100% Perl Code)
       primes1_c.pl (using Inline C)

 :: Practical Sieve based on serial code from Xuedong Luo (Algorithm3)

    A practical sieve algorithm for finding prime numbers
    ACM Volume 32 Issue 3, March 1989, Pages 344-346
    http://dl.acm.org/citation.cfm?doid=62065.62072

       primes2_p.pl (100% Perl Code)
       primes2_c.pl (using Inline C)

       primes3_p.pl (100% Perl Code, dual-level chunking)
       primes3_c.pl (using Inline C, dual-level chunking)

 :: Usage (please run on a 64-bit OS when N is greater than 32-bit)

    perl primes.pl <N> [ <run_mode> ] [ <max_workers> ]
 
    perl primes.pl 10000 1 8   ## Count primes only, 8 workers
    perl primes.pl 10000 2 8   ## Display primes and count, 8 workers
    perl primes.pl 10000 3 8   ## Find the sum of all the primes, 8 workers

    In addition, one can check a number for primality as well as specify a
    range. The dash can be omitted before -check and -between below.

    perl primes.pl -check 23
    perl primes.pl -between 900 950 [ <run_mode> ] [ <max_workers> ]

    The script exits with a status of 0 if a prime number was found,
    otherwise 2.


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Prime numbers are polled from an imaginary list by calculating the offset
    position and computing the value stored at that location. The computation
    is only applied for prime numbers and not composites. This, in my opinion,
    is faster than populating memory initially with primes and composites
    (both requiring the value to be computed).

    Very little memory is required to count and display all prime numbers
    between 2 and N. However, it does require 11 gigabytes of storage space
    to save all prime numbers between 2 and 1 billion to a file.

       primes3_c.pl 1000000000 8 0 > primes.out

    Workers have practically no communications requirement other than sending
    results after processing each chunk and the total count at the end of the
    run. Prime numbers are displayed to STDOUT in an orderly fashion as they
    are found.

 :: The *_c.pl examples require the following 2 packages under CentOS 6.3+
    to run. The 1st run will have Inline::C compile the C code -- this takes
    some time. The 2nd run and there after runs immediately with no overhead
    to compile the inlined C code.

       yum install perl-Inline perl-Parse-RecDescent


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Primes2 and primes3 are faster than primes1. The difference in time
    increases the greater N is. I ran with 32 and 48 workers at the
    time of testing.

    The 32-way box is configured with 2x Intel Xeon E5-2660 processors and
    memory running at 1600 MHz.

    N size needed to complete in 10 second (up to billions)

       perl primes1_c.pl 33000000000 1 32  completes in 10.2 secs
       perl primes1_c.pl 36000000000 1 48  completes in 10.3 secs

       perl primes2_c.pl 35000000000 1 32  completes in 10.1 secs
       perl primes2_c.pl 38000000000 1 48  completes in 10.2 secs
    
       perl primes3_c.pl 44000000000 1 32  completes in 10.2 secs
       perl primes3_c.pl 43000000000 1 48  completes in 10.3 secs
    
    N = 1 Trillion (12 zeroes)

       The winner below is primes3_c.pl with 32 workers. There is some overhead
       associated with the bank-teller queuing model in MCE. However, the delta
       is quite good for having 1.8 million chunks, standing in line, all sent
       to the next available teller in roughly 2 minutes time.

    <> primes1_c.pl

       1.5 million chunks, step_size = 128 * 2560 * 2

          perl primes1_c.pl 1000000000000 1 32  completes in 10.0 mins
          perl primes1_c.pl 1000000000000 1 48  completes in  8.7 mins

       There are 37607912018 prime numbers between 2 and 1000000000000.

    <> primes2_c.pl

       1.8 million chunks, step_size = 18 * 15000 * 2

          perl primes2_c.pl 1000000000000 1 32  completes in  8.2 mins
          perl primes2_c.pl 1000000000000 1 48  completes in  7.6 mins

       There are 37607912018 prime numbers between 2 and 1000000000000.

    <> primes3_c.pl

       4,088 big chunks (worker loops through each 302 times)
       big step_size = 244620000, loop step_size = 810000

          perl primes3_c.pl 1000000000000 1 32  completes in  5.9 mins
          perl primes3_c.pl 1000000000000 1 48  completes in  6.2 mins

       There are 37607912018 prime numbers between 2 and 1000000000000.

 :: The following disables the bank-queuing model for sequence. One creates a
    null structure for task_id 0 like shown. Sequence of numbers are divided
    equally among workers when task_id is greater than 0. The queuing model
    is only applicable to workers assigned task_id 0 or when omitting the
    user_tasks option.

       user_tasks => [ { }, {

          sequence   => [ 2, $N, $step_size ],

          user_begin => sub { ... },
          user_func  => sub { ... },
          user_end   => sub { ... }

       } ]

    I ran again just for comparison.

    perl primes2_c.pl 1000000000000 1 32  completes in  8.0 mins (- 12 secs)
    perl primes2_c.pl 1000000000000 1 48  completes in  7.8 mins (+ 12 secs)

    perl primes3_c.pl 1000000000000 1 32  completes in  6.3 mins (+ 24 secs)
    perl primes3_c.pl 1000000000000 1 48  completes in  6.4 mins (+ 12 secs)


###############################################################################
 # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * # * #
###############################################################################

 :: Thanks to Stephan Brumme for the initial inspiration. I wanted faster,
    continued looking and came across the practical sieve algorithm by
    Xuedone Luo (Algorithm3). Although serial code, thought it could run
    faster than primes1 if parallelized and indeed it does.

    Each worker utilizes only 8 ~ 10 MB no matter the size of N. Chunking
    in MCE makes this possible. Having an imaginary memory, that was the
    thought process, helped me rearrange the logic around. Why compute both
    primes and composites in the array when composites will eventually be
    crossed out. Therefore, computing composites is not necessary IMHO.

    Imaginary memory is of unlimited size. Computing the offset position
    into this memory space out weighs the cost of having a system with
    massive amount of memory for sieving prime numbers.

    
    -- Mario


