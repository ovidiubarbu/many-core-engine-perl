#labels Featured
= MCE Tasks =

Update October 27, 2014

This example demonstrates MCE::Flow, MCE::Queue, and MCE->gather.

https://metacpan.org/source/MARIOROY/MCE-1.519/examples/flow_model.pl

This demonstrates MCE::Flow and MCE::Queue.

https://metacpan.org/source/MARIOROY/MCE-1.519/examples/files_flow.pl

If interested, take a look at mce-sandbox (a journey with Perl + MCE + Inline::C).

https://github.com/marioroy/mce-sandbox

Regards,

- mario

The 1.2 release provides support for multiple tasks. Workers can be configured based on tasking.

http://many-core-engine-perl.googlecode.com/svn/wiki/img/MCE_Tasks.png

= Instantiation =

Setting it up is straight forward. A new option "user_tasks" takes an array of tasks. Each task allows for 5 options: max_workers, use_threads, user_begin, user_func, and user_end. Forking and threading can be inter-mixed among tasks.

{{{
use threads;
use threads::shared;
use Thread::Queue;

use MCE;

## Declare variables before calling MCE.
##
my $Q_POLLER = Thread::Queue->new;
my $Q_WRITER = Thread::Queue->new;

my $list_file = shift;

my $chunk_size  = 500;
my $max_pingers =   8;
my $max_pollers =  48;
my $max_writers =   8;

## Run Pingers, Pollers & Writers (all within one MCE instance).
## Below, use_slurpio is enabled to simulate cat file instead
## in user functions to keep the example small.
##
## The Pinger task spawns off child processes (forking). Therefore,
## workers pass the result back to the main process via a callback
## function. The callback function is executed by the main process
## which is able to append to the queue. The other 2 tasks are able
## to enqueue/dequeue directly since they are threads.
##
## The task_end block is executed by the main process.
##
my $mce = MCE->new(

   input_data  => $list_file,
   chunk_size  => $chunk_size,
   use_slurpio => 1,

   user_tasks  => [{
      max_workers => $max_pingers,
      user_func   => \&pinger,
      use_threads => 0,
      task_end    => sub {
         $Q_POLLER->enqueue( (undef) x $max_pollers );
      }

   },{
      max_workers => $max_pollers,
      user_func   => \&poller,
      use_threads => 1,
      task_end    => sub {
         $Q_WRITER->enqueue( (undef) x $max_writers );
      }

   },{
      max_workers => $max_writers,
      user_func   => \&writer,
      use_threads => 1

   }]
);

$mce->run();

exit;

 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #

sub pinger_cb {

   my ($chunk_ref) = @_;

   $Q_POLLER->enqueue($$chunk_ref);
}

sub pinger {

   my ($self, $chunk_ref, $chunk_id) = @_;

   if (defined $chunk_ref) {
      $self->sendto('stderr', "pinger: ", $self->wid(), "\n");
      $self->do('pinger_cb', $chunk_ref);
   }
}

sub poller {

   my ($self) = @_;
   my $wid = $self->wid();

   while ( my $buffer = $Q_POLLER->dequeue ) {
      $self->sendto('stderr', "poller: $wid\n");
      $Q_WRITER->enqueue($buffer);
   }
}

sub writer {

   my ($self) = @_;
   my $wid = $self->wid();

   while ( my $buffer = $Q_WRITER->dequeue ) {
      $self->sendto('stderr', "writer: $wid\n");
      $self->sendto('stdout', $buffer);
   }
}

}}} 

One no longer has to create multiple MCE instances to run multiple tasks in parallel. This can now be done with a single MCE instance via the new user_tasks option. All workers shared the same 4 socket channels. :)


- mario